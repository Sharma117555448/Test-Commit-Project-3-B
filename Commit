# -*- coding: utf-8 -*-
"""
Created on Sun Mar 28 22:45:09 2021

@author: sharm
"""

import cv2, math
import numpy as np
from datetime import datetime
import sys, random, math, pygame
from pygame.locals import *
from math import sqrt,cos,sin,atan2
from RRT_includes import *

#constants
XDIM = 720   #400 
YDIM = 500   #300 
WINSIZE = [XDIM, YDIM]
EPSILON = 7.0
NUMNODES = 5000
GOAL_RADIUS = 10
MIN_DISTANCE_TO_ADD = 1.0
GAME_LEVEL = 1

pygame.init()
fpsClock = pygame.time.Clock()

#initialize and prepare screen
screen = pygame.display.set_mode(WINSIZE)
pygame.display.set_caption('Rapidly Exploring Random Tree')
white = 255, 240, 200
black = 20, 20, 40
red = 255, 0, 0
blue = 0, 255, 0
green = 0, 0, 255
cyan = 0,255,255

# Defining the map
robot_world = np.zeros((300,400), dtype= np.uint8)

# Plotting the obstacles in the map
cv2.circle(robot_world, (90, 229), 35, 255, -1)

cv2.ellipse(robot_world, (246, 154), (60,30), 0, 0, 360, 255, -1)

pts_rect = np.array([[48, 191], [171, 105], [160, 90], [37, 175]], np.int32)
pts_rect = pts_rect.reshape((-1, 1, 2))
#cv2.polylines(robot_world, [pts_rect], True, 255, 1)
cv2.fillPoly(robot_world, [pts_rect], (255, 255, 255), 1)

pts_fig = np.array([[200,20], [200, 70], [230, 70], [230, 60], [210, 60], 
                    [210, 30], [230, 30], [230, 20]], np.int32)
pts_fig = pts_fig.reshape((-1, 1, 2))
cv2.fillPoly(robot_world, [pts_fig], (255, 255, 255), 1)

# Start and end point
initial_coordinate = [170, 320]
final_coordinate = [220, 330]#[220, 350]

initial_center = (initial_coordinate[0], initial_coordinate[1])
final_center = (final_coordinate[0], final_coordinate[1])
radius = 10.0
clearance = 5.0
circlePoints = []

start_time = datetime.now() # To calculate time

def dist(p1, p2):
    return math.sqrt((p1[0] - p2[0]) * (p1[0] - p2[0]) + (p1[1] - p2[1]) * (p1[1] - p2[1]))

def getPoints():
    for i in range(0, 300):
        for j in range(0, 400):
            d = dist((i, j), initial_center)
            if d <= radius + clearance and d > radius + clearance - 2:
                circlePoints.append((i, j))
# To check if the move should be made
def isSafe(new_center):
    for point in circlePoints:
        nx = point[0] + (new_center[0] - initial_center[0])
        ny = point[1] + (new_center[1] - initial_center[1])
        if nx < 0 or ny < 0 or nx >= 300 or ny >= 400:
            return False
        if robot_world[nx][ny] == 255:
            return False
    return True
def reset():
    global count
    screen.fill(black)
    init_obstacles(GAME_LEVEL)
    count = 0
    
# Functions for movements    
def move_up(cc):
    i=cc[0]
    j=cc[1] 
    if i > 0 and i <= 299:
        temp1 = i-1
        temp2 = j
        new_c = (temp1,temp2)
        return new_c
    return None

def move_down(cc):
    i=cc[0]
    j=cc[1]
    if i >= 0 and i < 299:
        temp1 = i+1
        temp2 = j
        new_c = (temp1, temp2)
        return new_c
    return None

def move_left(cc):
    i=cc[0]
    j=cc[1]
    if j > 0 and j <= 399:
        temp1 = i
        temp2 = j-1
        new_c = (temp1, temp2)
        return new_c
    return None

def move_right(cc):
    i=cc[0]
    j=cc[1]
    if j >= 0 and j < 399:
        temp1= i
        temp2= j+1
        new_c = (temp1,temp2)
        return new_c
    return None

def move_up_left(cc):
    i=cc[0]
    j=cc[1]
    if i > 0 and i <=299 and j > 0 and j <=399:
        temp1= i-1
        temp2= j-1
        new_c = (temp1,temp2)
        return new_c
    return None

def move_up_right(cc):
    i=cc[0]
    j=cc[1]
    if i > 0 and i <=299 and j >= 0 and j < 399:
        temp1= i-1
        temp2= j+1
        new_c = (temp1,temp2)
        return new_c
    return None

def move_down_left(cc):
    i=cc[0]
    j=cc[1]
    if i >= 0 and i < 299 and  j > 0 and j <= 399:
        temp1= i+1
        temp2= j-1
        new_c = (temp1,temp2)
        #print('down left', new_c)
        return new_c
    return None

def move_down_right(cc):
    i=cc[0]
    j=cc[1]
    if i >= 0 and i < 299 and j >= 0 and j < 399 :        
        temp1= i+1
        temp2= j+1
        new_c = (temp1,temp2)
        return new_c
    return None

# robot_location = []
# cost = 0.0


def end_game(start_coordinate):
    startNode = Node(start_coordinate)
    dij = {(start_coordinate[0], start_coordinate[1]) : 0.0}
    visited = set()
    getNode = {(start_coordinate[0], start_coordinate[1]) : startNode}
    
    print('Is the movement possible: ',isSafe(start_coordinate))

    def isGoal(loc):
        if loc[0] == final_coordinate[0] and loc[1] == final_coordinate[1]:
            print("\nReached the Goal!")
            return True
        else:
            return False


    while len(dij) > 0:
        currentNode = list(dij.keys())[0]
        currentCost = list(dij.values())[0]
        del dij[currentNode]
        #print(currentNode)
        visited.add(currentNode)
        

        if isGoal(currentNode):
            #print(currentCost)
            return getNode[currentNode]
        
        nextNode = move_up(currentNode)
        if nextNode != None and nextNode not in visited:
            if isSafe(nextNode) and nextNode not in dij: # first time
                getNode[nextNode] = Node(nextNode)
                dij[nextNode] = currentCost + 1.0
                getNode[nextNode].parent = getNode[currentNode]
                robot_world[nextNode[0]][nextNode[1]] = 150
                cv2.imshow('Visual', robot_world)
                cv2.waitKey(1)
            elif nextNode in dij:
                if currentCost + 1.0 < dij[nextNode]:
                    dij[nextNode] = currentCost + 1.0
                    getNode[nextNode].parent = getNode[currentNode]
        
        nextNode = move_down(currentNode)
        if nextNode != None and nextNode not in visited:
            if isSafe(nextNode) and nextNode not in dij: # first time
                getNode[nextNode] = Node(nextNode)
                dij[nextNode] = currentCost + 1.0
                getNode[nextNode].parent = getNode[currentNode]
                robot_world[nextNode[0]][nextNode[1]] = 150
                cv2.imshow('Visual', robot_world)
                cv2.waitKey(1)
            elif nextNode in dij:
                if currentCost + 1.0 < dij[nextNode]:
                    dij[nextNode] = currentCost + 1.0
                    getNode[nextNode].parent = getNode[currentNode]

        nextNode = move_right(currentNode)
        if nextNode != None and nextNode not in visited:
            if isSafe(nextNode) and nextNode not in dij: # first time
                getNode[nextNode] = Node(nextNode)
                dij[nextNode] = currentCost + 1.0
                getNode[nextNode].parent = getNode[currentNode]
                robot_world[nextNode[0]][nextNode[1]] = 150
                cv2.imshow('Visual', robot_world)
                cv2.waitKey(1)
            elif nextNode in dij:
                if currentCost + 1.0 < dij[nextNode]:
                    dij[nextNode] = currentCost + 1.0
                    getNode[nextNode].parent = getNode[currentNode]
        
        nextNode = move_left(currentNode)
        if nextNode != None and nextNode not in visited:
            if isSafe(nextNode) and nextNode not in dij: # first time
                getNode[nextNode] = Node(nextNode)
                dij[nextNode] = currentCost + 1.0
                getNode[nextNode].parent = getNode[currentNode]
                robot_world[nextNode[0]][nextNode[1]] = 150
                cv2.imshow('Visual', robot_world)
                cv2.waitKey(1)
            elif nextNode in dij:
                if currentCost + 1.0 < dij[nextNode]:
                    dij[nextNode] = currentCost + 1.0
                    getNode[nextNode].parent = getNode[currentNode]
        
        nextNode = move_up_right(currentNode)
        if nextNode != None and nextNode not in visited:
            if isSafe(nextNode) and nextNode not in dij: # first time
                getNode[nextNode] = Node(nextNode)
                dij[nextNode] = currentCost + 1.41
                getNode[nextNode].parent = getNode[currentNode]
                robot_world[nextNode[0]][nextNode[1]] = 150
                cv2.imshow('Visual', robot_world)
                cv2.waitKey(1)
            elif nextNode in dij:
                if currentCost + 1.41 < dij[nextNode]:
                    dij[nextNode] = currentCost + 1.41
                    getNode[nextNode].parent = getNode[currentNode]
        
        nextNode = move_down_right(currentNode)
        if nextNode != None and nextNode not in visited:
            if isSafe(nextNode) and nextNode not in dij: # first time
                getNode[nextNode] = Node(nextNode)
                dij[nextNode] = currentCost + 1.41
                getNode[nextNode].parent = getNode[currentNode]
                robot_world[nextNode[0]][nextNode[1]] = 150
                cv2.imshow('Visual', robot_world)
                cv2.waitKey(1)
            elif nextNode in dij:
                if currentCost + 1.41 < dij[nextNode]:
                    dij[nextNode] = currentCost + 1.41
                    getNode[nextNode].parent = getNode[currentNode]
        
        nextNode = move_up_left(currentNode)
        if nextNode != None and nextNode not in visited:
            if isSafe(nextNode) and nextNode not in dij: # first time
                getNode[nextNode] = Node(nextNode)
                dij[nextNode] = currentCost + 1.41
                visited.add(nextNode)
                getNode[nextNode].parent = getNode[currentNode]
                robot_world[nextNode[0]][nextNode[1]] = 150
                cv2.imshow('Visual', robot_world)
                cv2.waitKey(1)
            elif nextNode in dij:
                if currentCost + 1.41 < dij[nextNode]:
                    dij[nextNode] = currentCost + 1.41
                    getNode[nextNode].parent = getNode[currentNode]
        
        nextNode = move_down_left(currentNode)
        if nextNode != None and nextNode not in visited:
            if isSafe(nextNode) and nextNode not in dij: # first time
                getNode[nextNode] = Node(nextNode)
                

                dij[nextNode] = currentCost + 1.41
                visited.add(nextNode)
                getNode[nextNode].parent = getNode[currentNode]
                pygame.draw.line(screen,white,getNode[nextNode].config,getNode[currentNode].config)
                print(getNode[nextNode].config,getNode[currentNode].config)
                pygame.display.update()
                fpsClock.tick(10000)

                robot_world[nextNode[0]][nextNode[1]] = 150
                cv2.imshow('Visual', robot_world)
                cv2.waitKey(1)
            elif nextNode in dij:
                if currentCost + 1.41 < dij[nextNode]:
                    dij[nextNode] = currentCost + 1.41
                    getNode[nextNode].parent = getNode[currentNode]
        

        dij = dict(sorted(dij.items(), key = lambda item: item[1]))

    return None

# Saving the parent-child details         
class Node(object):
    def __init__(self, coordinate):
        self.config = coordinate
        self.children = []
        self.parent = None

    def add_child(self, obj):
        self.children.append(obj)
        obj.parent = self

getPoints()

goal_node = None
#circlePoints
#isSafe(initial_center)
# To check if the Start point and the End point are not in obstacle space
if isSafe(initial_center) == False or isSafe(final_center) == False:
    print("Try again: The robot location is not possible")
else:
    # main function call        
    # goal_node = end_game(initial_coordinate)
    goal_node = end_game(initial_coordinate)


# Show the optimal path
# Traverse the parents one by one from goal_node till dummy is hit
temp_goal = goal_node
try:
    print('The optimum path from the Goal to Start:')
    while temp_goal.config != initial_coordinate:
        robot_world[temp_goal.config[0]][temp_goal.config[1]] = 50
        temp_goal = temp_goal.parent
        print(temp_goal.config)
        cv2.imshow('Visual', robot_world)
        cv2.waitKey(1)
    robot_world[initial_coordinate[0]][initial_coordinate[1]] = 50
except:
    print("error")

while True:
    for e in pygame.event.get():
        if e.type == QUIT or (e.type == KEYUP and e.key == K_ESCAPE):
            sys.exit("Exiting")


# print("Total number of nodes possible: ", len(final_node)) 
end_time = datetime.now()
time_taken = end_time - start_time
print("Time taken: ", time_taken)   

cv2.imshow('Image', robot_world)
cv2.waitKey(0)
cv2.destroyAllWindows()
